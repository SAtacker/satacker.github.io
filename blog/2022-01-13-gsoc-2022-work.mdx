---
slug: gsoc-2022-work
title: GSoC 2022 Report
authors: [SAtacker]
tags: [GSoC, C++, HPX]
---

##  1. GSoC 2022 Report

<div align="center">
<img height="70%" width="70%" src="https://developers.google.com/open-source/gsoc/resources/downloads/GSoC-Horizontal.png" alt="GSoC @ HPX, STE||AR Group banner" />
<img src="https://raw.githubusercontent.com/STEllAR-GROUP/hpx/master/docs/sphinx/_static/images/HPX_STELLAR.png" alt="GSoC @ HPX, STE||AR Group banner" />
</div>

<!--truncate-->

##  2. About the project

[GSoC Project Acceptance Page](https://summerofcode.withgoogle.com/programs/2022/projects/YXhhTBJw)

Mentors
  - Dr. Hartmut Kaiser
  - Giannis Gonidelis

##  3. Objective

The main objective of this project was to enable the usage of co_await or to simplify - enable the usage of coroutines with the latest specs of Senders and receivers.

##  4. Abstract

HPX being up to date with Std C++ Proposals, Senders/Receivers were implemented as per P2300. But they have been missing coroutine (co_await) integration and minor functionalities as described in P2300 which is likely to be accepted. Hence I plan to implement these functionalities within the Core HPX Library. 
- Benefits: 
    - Coroutines introduce better async code. For example, it is more readable, local variables have the same lifespan as the coroutine which means we don’t need to worry about allocation/release. 
    - S/R algorithms can work with coroutines which they cannot as of now unless relied on futures which as mentioned are single-time use. 
    - Adding co_await support makes the code more structured with respect to concurrency which can also be done by library abstractions of callbacks but using co_await may make it more optimized.


##  5. Brief Summary

- Senders, and Receivers
    - Because it makes a more consistent programming model considering async programming types i.e. Parallelism and Concurrency. It standardizes the terminologies and execution policies which are more generic and reduce redundancy.
    - Coroutines have a direct connection between Senders and Coroutine Awaitables.
    - If you are familiar with Eric's [talk on live senders/receivers](https://www.youtube.com/watch?v=xiaqNvqRB2E), you might be comfortable watching [these diagrams](https://viewer.diagrams.net/?tags=%7B%7D&highlight=000000&edit=_blank&layers=1&nav=1&page-id=N1fN19OSE8Ezd9pb87vr&title=sender_receiver#R%3Cmxfile%3E%3Cdiagram%20id%3D%22EqYSzL36J7Lu1Ck5oe2v%22%20name%3D%22Page-1%22%3E5VrBcps6FP0az7SLZpAEGC8TN2kX7XttPXkvXSogA42MPEKuTb%2B%2BIohgIeLSsY1os7HRRULi3HOuriQmaL7aveN4nXxkEaET6ES7CXo7gRAgN5B%2FpaWoLIGDKkPM00hVagyL9AdRRkdZN2lEcq2iYIyKdK0bQ5ZlJBSaDXPOtnq1JaN6r2scE8OwCDE1rf%2BnkUjUW8BpY39P0jipewb%2BrLqzwnVl9SZ5giO23TOh6wmac8ZEdbXazQktwatxqdrdPHP3aWCcZKJPgyW6W37%2BTxBSxPz%2B07dbim9v3nhqbKKoX5hE8v1VkXGRsJhlmF431ivONllEyqc6stTU%2BcDYWhqBNH4jQhTKmXgjmDQlYkXVXTlgXtyV7S%2B8uvhVPe6x8HanlQpVqsZaDvBZCJQpZxsekgPvXVMJ85iIA%2FXgk6MkwwlbETke2Y4TikX6XR8HVlSLn%2Bo13pAXyiG%2F4Rz13O%2BYblRPizAh0YYSfpGrq1evDQ82%2FinB3iapIIs1foRjK0Wq%2B0J1Qbggu8OomiioBshXYlASB55i%2FLYRDKhVkOyJxXfOBZxrldZAI3XD8fPTGvakNbDKa2jymkjouX0me67GZDjrYLLrm0wOzsXkWjZ7WNmg9gkpivpSdGaTosiA%2Fd814bJjlknzQmBBrLMVOo7GVreLrYPGXddA7QsJiXSWlLZPZe9X9%2BVVXF69mrNMpNlGYXozx5Te4%2FDhtVnVOtJAB7ozLHgdQJ8tLNQDGniC26Xibu96b3qTpWZ2Kwv15NbketYmRb9nxLEacHxDOpd5kYVlVzRmPBXJyroMkKvrYGo90QusyMA%2Bpac9Ke3bpPTUoPRI0jwwGxuPZ2OFynPGBhWwu2Vhb20H%2Bi7uXJuiB74N99iAGR0Js2r6iaVyiE1S77eS%2BraQqnGpVi1nPQ3jCP%2BZi%2FO52lpt%2B1VGFaG7IRecPZA5o4xLS8ay0rnLlNKWCdM0zmQxlN6RQQ5dlTEqDTG9VDdWaRQ9MqMrwulsOUGQg0jHHNUxZi%2FI%2BR0xDp1t1Q8MsF9GXgNmPcUHj93A6laf35ruPDiw%2BsxEIC%2F3Gi7kLxcde72%2FyAD0dOEEUnFHt%2BcArUw4I8gHYN%2BJCnqn0Mol57jYq7AuNZAfkFKgM8V3vZavqyeeVD81Js%2Fs24VstaZEkHyEe0w%2BHJ2ypnZnIf1wEAyoLK%2Bnsqxm2vUo97j%2BDxPpsvh7E7X2BpSPTI0MmqghM97Y0MwJuV9D9evlzzOuGuh8xjxqeDHAH7vwPA5480DyhrPHiZ9kkfVZtL21FwS2Z1F04CuO3MBr6Hy%2BlaQBpyOiDoyXefRa7YXaBwvO3NGhZW6y%2F%2BlxsG%2FyhawebiBzpf5igA9sAu8iGziPYL3f3z%2BOTf8gc1lyhcOHN2PIDtqnWSPIDsxz%2F%2FqTGfvzXRsu4EDreAUGXsaHWfaB8%2F0BgZuUCXj9EXm1kdZ8io%2BufwI%3D%3C%2Fdiagram%3E%3Cdiagram%20id%3D%22RS2BbCfXYksCsHZpGadt%22%20name%3D%22Page-2%22%3E7VhNc5swEP01PqYDyGD72Nhpk2nSTutDnVNHhQ2oFYgRcozz67sYYcAysTPj2G7aE%2BzTB9J7b1caemQc5x8lTaM7EQDvOVaQ98ik5zg26Q%2FxUSDLEhlapARCyQLdqQam7Ak0aGl0zgLIWh2VEFyxtA36IknAVy2MSikW7W4Pgre%2FmtIQDGDqU26i31mgIr0LZ1Dj18DCqPqy7Y3KlphWnfVOsogGYtGAyFWPjKUQqnyL8zHwgryKl3Lch47W9cIkJGqfAfkduRGzTzfX4j69AAifbr8GF55em1pWG4YA969DIVUkQpFQflWjl1LMkwCKWS2M6j63QqQI2gj%2BAqWWWkw6VwKhSMVct%2BKC5XKmx6%2BC%2ByJ451bhJG82TpY6KtdaLLCTAg1lYi59eGbflZWoDEE9089dC4UOBxEDrgfHSeBUscf2Oqi2WrjuV6uBL1qQF4ij532kfK6%2F9CUFiR8WCcJTRRUY8tXiFEwvIqZgmtIVFwvM0LYQen6QCvLnKTUp0AMc2ymHLKsE0HZf1NliVykQNTLFs16Jtb7B2jfwAcWSJyerP%2FLOjKzBSfI%2FZ2rWeG9kP0Z18hdBlftnUDPcPWtG%2F5Q1wzXc%2F1ko9sDwDN1UGn2s2sJkSorfMBZcSEQSkRRyPzDONyDKWZhg6COHmFbkssgKhofme90QsyBYeWVbTrX9c4C0IsONGuS4Rlp5W7KKvFZWjfYvQdmCxZwmXVwduP64Voso1zXrj2NtYWoNHv6McwyuMlA%2FMiXSFD2y27P7e1FCxp7oz9VUhfNSwRK12o972XMnxVxYqrKyar0kHfZSptsonXJtqGUTU63RMW1tmxeSQivAa7Zp7H9KKa%2Bt1MgUanBUoaytQpXhf6EaBfDUQhFDqN1X%2FKMeGfaozRjZcmU99pHhme7GS5l6684uzdKp1GCntd2jWntgqDQFvPed2RXoDPzsmNW6%2Bpv11h09%2BJuKtWNef6Z%2BBMGcn9rUm0X6DO71jvkbJusk643ZeodarrvL1sPD2BrD%2Bvfyqq3xk55c%2FQE%3D%3C%2Fdiagram%3E%3Cdiagram%20id%3D%22dfIvOOW6uf5FMUzMlSmy%22%20name%3D%22Page-3%22%3E5VrLcpswFP0az6SLdngYbC9rnDSLpJ0m7fSxyahGASWAGCFiO1%2FfCwgwSNhpJ8aOvTI6CD3OuboP8MB0wuUnhmL%2Fmro4GBiauxyYs4Fh6OZwDD8ZsiqQsWYWgMeIKzrVwC15xgLUBJoSFyeNjpzSgJO4Cc5pFOE5b2CIMbpodrunQXPWGHlYAm7nKJDRH8TlvtiFMarxS0w8v5xZtyfFnRCVncVOEh%2B5dLEGmecD02GU8uIqXDo4yMgreSmeu%2Bi4Wy2M4Yi%2F6IEpir9MnWD29fHq4vnSumb%2B%2FL0QI%2BGrcsPYhf2LJmXcpx6NUHBeo1NG08jF2agatOo%2BV5TGAOoAPmDOV0JMlHIKkM%2FDQNwt5swm6tyKgBKasjnesP7SJBDzMN%2FQz6gIB0vFNMScreA5hgPEyVNzHUiYjFf1q1mFC0HsP5Asxn1CQSpmusXAIAPsAs05ZQQsvK1DzXJG2cInHN%2FGKCdjAUdNxegTZhwvN3Mqc1A%2BMBR2Kg5q2VzUVq%2BXpuyvWbyt7Yg1Q2LtIU34wfGk2%2Fsmaqgk6i4pbWxg2CjMiAhgJdNvVdPjFSNrfCYLEgYowr2QObSbZJoyl4am4LICX51MSyIzgQOKK6hNF%2BydN2lBAfEiuJ4DB8C%2FOc0YIhBRPoobIXHdwpHihDyjP%2FlQmSuNKYl4viFrOrBm2VjgO5PCjWZDJ5zRR%2BzQgMK4s4jmKt2TIGhBL1Om05Y65WqpZVmSWmOFWOautLIlre7BlUbuWjpw0nJZLU%2BlKzyV6nTtTLCRJFilU8tL3bS9lHbWcGowv3bz7sCc1%2F69V6nwGsMM85RFgNEYM0h2aJRThvjR%2B7LRRvXM9uGQnVkV6ns5HGNJOo4ecZ6kzjHkqOy09SqDjdDLluWa9KmWrktyvK3KSQTPrZVThyo9VU5yEaBwY3LscA46y7WN%2FQcKUyI2z3OTOtF1Tsj16B3vB9SxQpH39hsqdLnkqzJfOBPs6PPeLXrZ22N7r4VKOX%2B%2FwQIoZKuf2fMfrLL5SwyXN2bLRmslWq8YZMp8dGuU6RK0pzAjV5LiGDXKjgOrN8bjyd7DyOhUDXv4UsO292rYclGRYH6XN8%2Fq4O6UXWQLf8OBY%2FNhGjcP08RUBHV7R0Ei0RIn9cfk8%2BQu%2Fc5HxJt9%2Ba34SnDTlX316naqV0R7ec2hpEquCur0B8wbMtk4BgdzPLbcbTDdOWuzXtYVqik%2FU%2BzMvuWKoyEaZoweU53xH5INm5JNFIrt6nWtcrWbqowyipy4Yq3CUKGY%2FjqKQbP%2Bq0B%2Bb%2B0PF%2Bb5Xw%3D%3D%3C%2Fdiagram%3E%3Cdiagram%20id%3D%22zS0qvL6dZnKoQc5eDSts%22%20name%3D%22Page-4%22%3E5Vpbc%2BI2FP41zKQP3fEdeFwgadN2p%2BkynSRPGS0W4MRYriwC5Nf3yJZtZAkDGwwJPIGOj2zr%2B3Sucsvuz5a%2FURRPvxEfhy3L8Jcte9CyLNN2OvDDJatM0jHsTDChgS%2BUSsEweMNCaAjpPPBxIikyQkIWxLJwRKIIj5gkQ5SShaw2JqH81BhNsCIYjlCoSu8Dn03FKqx2Kf8dB5Np%2FmTT62ZXZihXFitJpsgnizWRfd2y%2B5QQlv2bLfs45ODluGTzbjZcLV6M4ojtMuHh8Xn%2B9%2F3SuOs9P%2F35z%2Bs3cvvH26%2BCjFcUzsWCxcuyVY4A9gEQMSSUTcmERCi8LqU9SuaRj%2FljDBiVOn8REoPQBOEzZmwl2EVzRkA0ZbNQXM2eyR%2B0cW1ClJA5HeGaBeV7BNEJZjV6VsEAbF1MZpjRFcyjOEQseJXfA4k9NCn0Spjhj0B6D9RNBfX%2BFAURiBaEvigMlPhysBbTgOFhjFIYFmB1OixfMWV4WY%2BmunoxId%2BxwmQdMVyU%2B9%2FMVaZre98zGoLLUuBiUxwpMG0BRkbx8DCZnVPj5G7AyUMzjkUIz%2B8NWxbc3LgppBOWomFcJRjgoXB5PI9GLCDRLwrCySKYhSjC23dhAgbIhL3bxmHwLlxrDrihAm4ZGsAL4eEN2T6FuwS86OqBz%2F%2Fi5sNHcbt0MFhKo5UYHdDNeju62fYp3ayn2APFbE6jhL85WMZTvuUrFMIWZTLiKAwmEfwfAVAwwe7xjRxAlvBVXJgFvp%2BRi5PgDf1Ib8Uxj0kQsXRhbq%2FlDvi9gM8kozazFEpecJ%2BEBO47iEhqXeMgDCuigzgsRzYg11U9lq0xILsp%2B2lrPVbByy6O66ddVAMeyW6f3CN1FUTHNAA411Lk89nu%2B7gccRe3ErQ1McTUMdaYCXQUwoaMAKwgG%2BYRme97EZTPiL0tttWVnZVjapyVe0ymTDVtL0zKkJ3VdzW9khwbZ%2FT7e%2FKrBpyXp8nzj51Offbqs7tjWmRuoOZI5WfnFDCvZa3OXmlrOrrDNIDVc3926FzWdHZlzT0pa47ifirpLIkxRZcVJDqyD2vrgoRz1CChL8LXuTG0iS2EjP6HTm67Ry23Bw%2FD%2F95eZrf3j0%2FP9v2%2FRmzf3OYNjk8bHkxN2axd6HvDQzr1K6VotaYgDLe88x0XlIQ7RoXwbqWhvEXfM%2Bv1Xdep04c%2F2RuX%2B6NY%2BjvsUW0CJHl%2BvW6TCUMMX47f7Faobp%2Fcb6qtgKJwTZuJF8MNkCNxYxqaoNZpiJvN3kiiZrvlHDVUOc4OpYx51FBlqWnAKsY8%2BPOBl0b%2BH7zFlUZ6UUeWPfg0Z6B4hMHbU7VQ%2FLx7f59wl8cNmVtNw6arodZpiln1yFQiS2kEfKysrmoqHyCrU%2Bua0vNj9pTJz9wC7HrSZBNwNMFa590aCwhqz1JiDBKsOIaU%2B7I5qzSaTY3f0p0ON0ZaXYIFpGFKAZaLpqxyNqA7z2%2FqaED7tupZTlq6pIVgHmx462B8fmcDBzA43eFmUyWN9nU9hY8P262oS2G3Nis20HLwrqg%2BdTRUI9mYNPzc9yuWfajUS96h%2BtNi95ipV37gsn6khfi0aoFSYHq15nq437lKpVChGOdfpRi19La%2FyFmaht3jFir5eeU5f5xUV1Bs77JuILTZNmu7I7uBrlffNq3q2%2B6WNmvVzcj6%2B7ZZYVh%2Bo5ypl19629f%2FAw%3D%3D%3C%2Fdiagram%3E%3Cdiagram%20id%3D%22N1fN19OSE8Ezd9pb87vr%22%20name%3D%22Page-5%22%3E7VvRbqM4FP0apO5DKzABkscm7XRWsytVk0ozOy%2BRA07iHYIZY5pkvn5tcEKwTWi7DRklI1URvhgD59x7fH1NLXe0XD9QmC7%2BJhGKLWBHa8u9swAIPI%2F%2FCsNGGgZ%2BaZhTHJUmpzKM8U8kjba05jhCWa0jIyRmOK0bQ5IkKGQ1G6SUrOrdZiSu3zWFc6QZxiGMdesXHLFFae2DoLJ%2FRHi%2B2N7Z8QflmSXcdpZvki1gRFZ7JvfeckeUEFYeLdcjFAvstriU131oOLt7MIoS9pILso%2Ff%2Bt%2B8py%2BD9e0mmz4l9M%2FVj2s5yjOMc%2FnC2SYJJyuImQV8uEwtdxjz4YfjXXMumlcZSiJE%2F5CvxjZbvLIVXsYw4a3haoEZGqcwFKdW3Du4bcGWMW85%2FFDeGVGG1o2v5OyA4g6GyBIxuuFd5AXAk9hK5wKubK8qqkBf2hZ7NAFfGqF0j%2Flu7ApBfiBBfAWgQAOUIpbTJOP4FUBOKT8qMCQpwySBcR3oEtgJRVkes8lhFtSWwgUHltUxhzGeJ%2Fw45AAjyg0Cfsy9%2FVaeWOIoEpcP%2Bf3xTzgthrJ5OyU4YQVY3tDy7sRYOSNZGa9i6IxR8h2NSEz4uHcJKVxghuNYMb2I9mZfbfQF1RUc3RUckyv03sETPj0MJ4%2Fws%2F%2Fp6WHqXvuf8yeQHQ4tO4IMXjZh%2FTphhtB1bANf7tH40kN3O6lwkoqoLCYfS%2BisGss7annghgg%2Fi75qn3ooG8Z4XeQ3jf5bC4Dv1VzLM7iWa3CtwbFcC%2Fi6FjBIhWORFFEo5oHLZiwY1BhzTq4GoK9Rlif4R44mMQm%2F6%2BEXPt%2BI8L8qz46ESHhVTJa%2FAvlgWOYDcgq4iSSuwZ2eS12UB4Be3QN8QyrndDl%2F69NBJfLG2bvT1Nd16nh5BpEDpojZGd8dsJ4G2DIXL3g%2Bbt3sJ83CZis0aSz5XcqaZ8pxIrxdiPATFBfwXjRpbj1%2F6L8wfzgaa3r6MCUkRvCckoY30KSkeY5hyRd0SVOg0YTWIUrPLLt7B6IMc1WnRLkaHSiao7FsEsoWZC4E8b6yDinJ%2BfIskpBXff4iJJUw%2F4sY28gSpmDANOmLGx2e8vlzkZyG6MDzbwuhkM7RG1ihKOZLjuf6c5hALi69pRRu9jpIb6tGfhSGvUTOrk95IPD2CWvt73u2QnD5BBXdu1d5uwfo2f3rVt%2BnTP28gQJw7%2BSp30CDs8LRJrP9Akpx2h5b7i3%2FY2ekiy0lCaeuga4hE9zpYjf1LkcDvwMV5HDRzVdx%2FY3H0yxp%2BKcw2PbOcLeWtyhbm%2F3WI6KYQyB8oTC%2BTVgPVe9bhbV%2FCmH1lBJ3L1A2fFr6b12pqb8%2FCA71P44QO66uxKZa6p4YP%2F1KYuzb6gLPJMZel2Ls6Iu8jBGKCgedIf5moTguKtnVHpTsfj56fMDdGtlURNo3aPSgU43W85QZxXwqLWZUNkGUclwumzNF5UyLi443kvR14G%2FSWkgDJydNr142imZIeBpCxJDTstx%2FNlS2zXXKvlr%2F1PoIPA38jnPYWgbbkr1a71gBkCXB9hKAbab0xanq%2F4sqvXJZk8Jzyzla4qenpBc9Q%2FyY9riOFz%2B2rnpbWq6q7HtUxEDR7cRffHmD4EYtzp884d6%2BhrZXzG1nNkG8SmN269AaYYZqlem7rOP5PNDYKg5vKEpj7rpXRi%2B%2FLMoUoQoM2RnolDNDlQAVn9EJIGRaxuhZzSVv4k1Jqw3a2PEEo6fVCWF4tqm4W2H%2BaEVSfYn70If5vG7fODN%2BFHO8nTNbY%2BRCEu6XloabFr7HrQ27yte0XkutN7DdQ%2F1fW%2BvlzeofGcru1X%2BDuPf%2FAQ%3D%3D%3C%2Fdiagram%3E%3C%2Fmxfile%3E).

- Futures
    - One of the points of S/R is to avoid the allocations associated with futures, also, futures are single-use, whereas S/R, in general, can be used (started) multiple times. - Dr. H. Kaiser


Goal is to enable all Sender CPOs to do the following:
- If we write a sender and pass it to a function which could be a coroutine that could co_await that sender and get its result.
- If they are not generally awaitable then we can await transform them (i.e. make them awaitable).


##  6. More Context on:

###  6.1. Coroutines

Quoting from the below references:
- Some senders are awaitables
- All awaitables are senders
- When the coroutine is in a suspended state it basically becomes a callback function but we know callbacks are straightforward receivers, then coroutines are receivers and awaitables are senders.

###  6.2. Senders and Receivers

- Senders are just a lazy value
- Receivers are like callbacks which provide 3 slots
  - set_value
  - set_error
  - set_stopped
- The relationship between these two is that the sender passes the values to the receiver which has 3 specific slots to report to.
- A Scheduler is a handle where these computations will be performed. These produce senders which maybe accepted by the async algorithms.

##  7. Work

My PRs can be found using [this](https://github.com/STEllAR-GROUP/hpx/pulls?q=is%3Apr+author%3ASAtacker) link as it'll always be updated.

Following are the Merged PRs until now:

Minor Improvements:

- [[execution] Add schedule_result_t alias template](https://github.com/STEllAR-GROUP/hpx/pull/5846)
  - This was a warm-up PR to ensure that I can read the standard reference implementation and can write tests that are necessary.
- [[hpx::execution] Added forwarding_scheduler_query](https://github.com/STEllAR-GROUP/hpx/pull/5865)
  - I revised a lot of tag_* mathods especially [tag_invoke](https://www.open-std.org/jtc1/sc22/WG21/docs/papers/2019/p1895r0.pdf). 
  - Found minor bug in the implementation for it and fixed it [link](https://github.com/STEllAR-GROUP/hpx/pull/5865/files#diff-c220d96705c8982a255599928a8fce5d89c4d0b54344d7357177bd8c22f5f67f)
  - As far as the tests went it was pretty clear that we need to test the CPO using a custo implementation
- [[P2300] enhancements: receiver_of, sender_of improvements](https://github.com/STEllAR-GROUP/hpx/pull/5920)
  - A good revision of SFINAE helped me implement the following metafunctions
        `is_invocable_variant_of_tuples`, `is_invocable_variant`
  - Added `sender_of` concept that defines the requirements for a sender type that on successful completion sends the specified set of value types.
  - Added `receiver_of` concept takes a receiver and an instance of the `completion_signatures<>` class template.
  - Tons of tests for all the above.
- [[P2300] Added fundamental coroutine_traits for S/R](https://github.com/STEllAR-GROUP/hpx/pull/5945)
  - Firstly I had to modify the C++ compiler check for C++ 20 Coroutines functionality.
  - This led to an addition of a new `hpx/config/coroutines_support.hpp` header.
  - An awaiter concept - An Awaiter type is a type that implements the three special methods that are called as part of a co_await expression: await_ready, await_suspend and await_resume.
  - An awaitable concept - Something that you can apply the ‘co_await’ operator to. If the promise type defines an await_transform() member then the awaitable is obtained by calling `promise.await_transform(value)`, passing the awaited value. Simply checks whether the type supports applying the co_await operator to avalue of that type. If the object has either a member or non-member operator co_await() then its return value must satisfy the Awaiter concept. Otherwise, the Awaitable object must satisfy the Awaiter concept itself.
  - Tons of tests as usual

Major Work:

1. Adapt `get_completion_signatures` when Sender is a awaitable
This confused me for a while actually. There was a minor bug in the P2300 5th Rev Specification. It did not consider the environment for awaitables i.e. it did not consider the promise type for awaitables. All those awaitables whose promise type defines await_transform would not be considered awaitables and there won't be any completion signatures for them. This led to a further discussion recently with Eric Niebler. I think that it will be revised even further. But for now we can deal with senders that expose a co_await operator.
2. Utility `as_awaitable_t`
    - `receiver_base`, `sender_awaitable_base` 
    - to transform an object into one that is awaitable within a particular coroutine.
3. promise base for 5.
4. operation base for 5.
5. Utility `connect_awaitable` to adapt `connect` mentioned in [spec](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2300r5.html#spec-execution.senders.connect) 2.2
6. Utility `with_awaitable_senders`  
    - Used as the base class of a coroutine promise type, makes senders awaitable in that coroutine type

[This](https://github.com/STEllAR-GROUP/hpx/pull/5990) is the PR for the above work.

##  8. Future work

- Test these on all the algorithms that returns a sender.

##  9. Extra Contribution

- I discovered a bug in the standard specification of P2300 which is filed as an issue and made a PR to the reference implementation for this issue is currently in progress. [here](https://github.com/brycelelbach/wg21_p2300_std_execution/pull/602)


##  10. Example Code

```cpp

template <typename T>
struct custom_task
{
    template <typename A>
    struct custom;
    using promise_type = custom<T>;

    custom_task() = default;

    custom_task(custom_task&& that) noexcept
      : coro_(std::exchange(that.coro_, {}))
    {
    }

    ~custom_task()
    {
        if (coro_)
            coro_.destroy();
    }

    explicit custom_task(
        hpx::coro::coroutine_handle<promise_type> __coro) noexcept
      : coro_(__coro)
    {
    }

    struct final_awaitable
    {
        static std::false_type await_ready() noexcept
        {
            return {};
        }
        static hpx::coro::coroutine_handle<> await_suspend(
            hpx::coro::coroutine_handle<promise_type> h) noexcept
        {
            return h.promise().continuation();
        }
        static void await_resume() noexcept {}
    };

    template <typename A>
    struct custom
      : hpx::execution::experimental::with_awaitable_senders<custom<T>>
    {
        custom_task get_return_object() noexcept
        {
            return custom_task(
                hpx::coro::coroutine_handle<promise_type>::from_promise(*this));
        }
        hpx::coro::suspend_always initial_suspend() noexcept
        {
            return {};
        }
        final_awaitable final_suspend() noexcept
        {
            return {};
        }
        void unhandled_exception() {}

        void return_value(T value) noexcept
        {
            data_.template emplace<1>(std::move(value));
        }
        std::variant<std::monostate, T, std::exception_ptr> data_{};

        custom_task context_;
    };

    template <typename ParentPromise = void>
    struct task_awaitable
    {
        hpx::coro::coroutine_handle<promise_type> coro_;
        std::optional<custom<ParentPromise>> context_{};

        static std::false_type await_ready() noexcept
        {
            return {};
        }
        template <typename ParentPromise2>
        hpx::coro::coroutine_handle<> await_suspend(
            hpx::coro::coroutine_handle<ParentPromise2> parent) noexcept
        {
            coro_.promise().set_continuation(parent);
            return coro_;
        }
        T await_resume()
        {
            context_.reset();
            if (coro_.promise().data_.index() == 2)
                std::rethrow_exception(
                    std::get<2>(std::move(coro_.promise().data_)));
            if constexpr (!std::is_void_v<T>)
                return std::get<1>(std::move(coro_.promise().data_));
        }
    };

    friend task_awaitable<> operator co_await(custom_task&& self) noexcept
    {
        return task_awaitable<>{std::exchange(self.coro_, {})};
    }

    template <typename ParentPromise>
    friend task_awaitable<ParentPromise> tag_invoke(
        hpx::execution::experimental::as_awaitable_t, custom_task&& self,
        ParentPromise&) noexcept
    {
        return task_awaitable<ParentPromise>{std::exchange(self.coro_, {})};
    }
    hpx::coro::coroutine_handle<promise_type> coro_;
};

template <typename S1,
    typename = std::enable_if_t<hpx::execution::experimental::is_sender_v<S1>>>
custom_task<int> async_answer_custom(S1 s1)
{
    // Senders are implicitly awaitable (in this coroutine type):
    co_return co_await (S1 &&) s1;
}
```

```cpp
    try
    {
        // Awaitables are implicitly senders:
        auto i = hpx::this_thread::experimental::sync_wait(
            async_answer_custom(hpx::execution::experimental::just(42)))
                     .value();
        std::cout << "The answer is " << hpx::get<0>(i) << '\n';
    }
    catch (std::exception& e)
    {
        std::cout << e.what() << '\n';
    }
```


##  11. References

- [P2300](https://wg21.link/P2300)
- [the reference implementation](https://github.com/brycelelbach/wg21_p2300_std_execution)
- [libunifex](https://github.com/facebookexperimental/libunifex)
- [HPX main P2300 Issue](https://github.com/STEllAR-GROUP/hpx/issues/5045)

- Talks
  - "A Tour of C++ Executors, Part 1": https://www.youtube.com/watch?v=xLboNIf7BTg
  - "A Tour of C++ Executors, Part 2": https://www.youtube.com/watch?v=6a0zzUBUNW4
  - "Live-coding sender/receiver": https://www.youtube.com/watch?v=xiaqNvqRB2E
  - "A Unifying Abstraction for Async in C++": https://www.youtube.com/watch?v=tF-Nz4aRWAM
  - "Structured Concurrency": https://www.youtube.com/watch?v=Xq2IMOPjPs0
  - "Structured Networking": https://www.youtube.com/watch?v=nmQgVVQCFu4
  - "C++ Standard Parallelism": https://www.youtube.com/watch?v=r1COmv0CdW4 

import Comments from '../src/components/comments/Comments'

<Comments />
